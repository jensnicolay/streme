
(define (d exp . messages)
	(display messages) (display '==>) (display exp) (newline) exp)

(define *any* (Object.))

(define (create-lset . els)
	els)
	
(define (lset-add el s)
	(if (member el s)
		s
		(cons el s)))
		
(define (lset-add-all els s)
	(if (null? els)
		s
		(lset-add-all (cdr els) (lset-add (car els) s))))
				
(define (lset-union ls1 ls2)
	(lset-add-all ls1 ls2))
	
(define (lset-member? el s)
	(member el s))

(define (create-lsetmap)
	'())
	
(define (lsetmap-put key value lsetmap)
	(if (null? lsetmap)
		(list (cons key (create-lset value)))
		(let ((entry (car lsetmap)))
				(if (equal? (car entry) key)
					(cons (cons key (lset-add value (cdr entry))) (cdr lsetmap))
					(cons entry (lsetmap-put key value (cdr lsetmap)))))))

(define (lsetmap-get key lsetmap)
	(let ((entry (assoc key lsetmap)))
		(if entry
			(cdr entry)
			'())))
			
(define (perm l)
  (if (null? (cdr l))
      (map list (car l))
      (let ((rest (perm (cdr l))))
        (apply append (map (lambda (x)
                             (map (lambda (y)
                                    (cons x y))
                                  rest))
                           (car l))))))
			
(define (create-time)
	'())
	
(define (time-tick value k time)
	(let ((result (append time (list value))))
		(if (> (length result) k)
			(cdr result)
			result))) 
	   
(define (create-var-address var time)
	(vector 'var var time))
	
(define (var-address? object)
	(and (vector? object) (eq? 'var (vector-ref object 0))))
	
(define (var-address-var avar)
	(vector-ref avar 1))
	
(define (var-address-time avar)
	(vector-ref avar 2))
	
(define (%create-aval values fresh mono)
	(vector values fresh mono))
	
(define (create-aval values)
	(%create-aval values #t values))
	
(define (aval-values aval)
	(vector-ref aval 0))
	
(define (aval-fresh? aval)
	(vector-ref aval 1))
	
(define (aval-mono aval)
	(vector-ref aval 2))
	
(define (aval-update values aval)
	(if (aval-fresh? aval)
		(aval-strong-update values aval)
		(aval-weak-update values aval)))
		
(define (aval-weak-update values aval)
	(%create-aval (lset-union values (aval-values aval)) #f (lset-union values (aval-mono aval))))
	
(define (aval-strong-update values aval)
	(%create-aval values (aval-fresh? aval) (lset-union values (aval-mono aval))))
	   	   
(define (aval-reset aval)
	(%create-aval '() #t (aval-mono aval)))	   	   
	   	   
(define (create-store)
	'())
	
(define (store-lookup-entry address store)
	(assoc address store))

(define (store-lookup address store)
	(let ((entry (store-lookup-entry address store)))
		(if entry
			(cdr entry)
			(error (String/format "no value at address %1s" (vector address))))))

(define (store-update address value store)
	(if (null? store)
		(cons (cons address value) '())
		(let ((entry (car store)))
			  (if (equal? (car entry) address)
			  	(cons (cons address value) (cdr store))
				(cons entry (store-update address value (cdr store)))))))

(define (store-keep-all addresses store)
	(if (null? store)
		'()
		(let ((entry (car store)))
			(if (member (car entry) addresses)
				(cons entry (store-keep-all addresses (cdr store)))
				(store-keep-all addresses (cdr store))))))
	
(define (store-lookup-aval address store)
	(let ((entry (store-lookup-entry address store)))
		(if entry
			(aval-values (cdr entry))
			(error (String/format "no aval to lookup at address %1s" (vector address))))))
	
(define (store-alloc-aval address values store)
	(let ((entry (store-lookup-entry address store)))
		(if entry
			(store-update address (aval-weak-update values (cdr entry)) store)
			(store-update address (create-aval values) store))))
			
(define (store-update-aval address values store)
	(let ((entry (store-lookup-entry address store)))
		(if entry
			(store-update address (aval-update values (cdr entry)) store)
			(error (String/format "no aval to update at address %1s" (vector address))))))

(define generate-benv-address
	(let ((c 0))
		(lambda ()
			(set! c (+ c 1))
			(cons 'benv c))))
			
(define (benv-address? object)
	(and (pair? object) (eq? 'benv (car object))))
			
(define (%create-benv frame parent-pointer)
	(cons frame parent-pointer))
	
(define (benv-frame benv)
	(car benv))	
	
(define (benv-parent-address benv)
	(cdr benv))	

(define (benv-extend name address benv)
	(%create-benv (cons (cons name address) (benv-frame benv)) (benv-parent-address benv)))
	
(define (benv-addresses benv)
	(map cdr (benv-frame benv)))
	
(define (store-benv-lookup benv-address name store)
	(if benv-address
		(let* ((benv (store-lookup benv-address store))
		       (entry (assoc name (benv-frame benv))))
			(if entry
				(cdr entry)
				(store-benv-lookup (benv-parent-address benv) name store)))
		(error (String/format "no binding for name %1s" (vector name)))))
	
(define (store-benv-extend benv-address name address store)
	(let ((benv (store-lookup benv-address store)))
		(store-update benv-address (benv-extend name address benv) store)))
		
(define (store-alloc-benv address parent-pointer store)
	(store-update address (%create-benv '() parent-pointer) store))
				
(define (store-benv-addresses benv-address store)
	(if benv-address
		(let ((benv (store-lookup benv-address store)))
			(cons benv-address (append (benv-addresses benv) (store-benv-addresses (benv-parent-address benv) store))))
		'()))
			
(define (%create-cont previous benv applications proc)
	(vector previous benv applications proc))
	
(define (create-cont previous-address benv proc)
	(%create-cont previous-address benv '() proc))
	
(define (cont-previous-address cont)
	(vector-ref cont 0))
	
(define (cont-benv cont)
	(vector-ref cont 1))
	
(define (cont-applications cont)
	(vector-ref cont 2))

(define (cont-proc cont)
	(vector-ref cont 3))	
	
(define (cont-call cont values)
	((cont-proc cont) values))
	
(define (cont-add-application application cont)
	(%create-cont (cont-previous-address cont)
	              (cont-benv cont)
	              (cons application (cont-applications cont))
	              (cont-proc cont)))

(define generate-cont-address
	(let ((c 0))
		(lambda ()
			(set! c (+ c 1))
			(cons 'cont c))))
			          
(define (store-stack-applications cont-address store)
	(let loop ((cont-address cont-address)
	           (result '()))
		(if cont-address
			(let ((cont (store-lookup cont-address store))) 
				(loop (cont-previous-address cont) (append (cont-applications cont) result)))
			result)))
			
(define (store-cont-call cont-address values store)
	(let ((cont (store-lookup cont-address store)))
		(cont-call cont values)))
		
(define (store-cont-add-application cont-address application store)
	(let ((cont (store-lookup cont-address store)))
		(store-update cont-address (cont-add-application application cont) store)))
			
(define (create-closure lam benv)
	(vector 'closure lam benv))
	
(define (closure? object)
	(and (vector? object) (eq? (vector-ref object 0) 'closure)))

(define (closure-lambda closure)
	(vector-ref closure 1))
	
(define (closure-benv closure)
	(vector-ref closure 2))
		
(define (create-calling-context operator operands time)
	(vector operator operands time))
			
(define (benv-reachable benv-address reachable store)
	(if (or (not benv-address) (lset-member? benv-address reachable))
		reachable
		(let ((benv (store-lookup benv-address store)))
			(benv-reachable (benv-parent-address benv) (frame-reachable (benv-addresses benv) (cons benv-address reachable) store) store))))

(define (frame-reachable addresses reachable store)
	(if (null? addresses)
		reachable
		(let ((address (car addresses)))
			(if (lset-member? address reachable)
				(frame-reachable (cdr addresses) reachable store)
				(let loop ((values (store-lookup-aval address store))
				           (reachable (cons address reachable)))
					(if (null? values)
						(frame-reachable (cdr addresses) reachable store)
						(let ((value (car values)))
							(cond ((closure? value)
							       (loop (cdr values) (benv-reachable (closure-benv value) reachable store)))
							      (else (loop (cdr values) reachable))))))))))
							      
(define (cont-reachable cont-address reachable store)
	(if (or (not cont-address) (lset-member? cont-address reachable))
		reachable
		(let ((cont (store-lookup cont-address store)))
			(cont-reachable (cont-previous-address cont) (benv-reachable (cont-benv cont) (cons cont-address reachable) store) store))))
		
							     
(define (store-gc benv-address cont store)
	(let ((reachable (cont-reachable cont (benv-reachable benv-address '() store) store)))
		(let loop ((todo store)
		           (result '()))
			(if (null? todo)
				result
				(let* ((entry (car todo))
				       (address (car entry)))
					(if (member address reachable)
						(loop (cdr todo) (cons entry result))
						(if (var-address? address)
							(loop (cdr todo) (cons (cons address (aval-reset (cdr entry))) result))
							(loop (cdr todo) result))))))))
						
		
(define (ipda-eval node k ast)
	
	(define result (create-lsetmap))
	(define store (create-store))
	(define reads (create-lsetmap))
	(define writes (create-lsetmap))
	(define calling-contexts (create-lsetmap))
	(define time (create-time))
	
	(define (eval-literal node benv cont-address)
	   (store-cont-call cont-address (create-lset (literal-value node)) store))
		
	(define (eval-define node benv cont)
		(let ((define-cont 
		        (create-cont cont 
							 benv 
                             (lambda (values)
                             	(let* ((var (define-var node))
                               	       (address (create-var-address var time)))
                               	   (set! store (store-benv-extend benv (var-name var) address store))  
                                   (set! store (store-alloc-aval address values store)) 
		       				       (store-cont-call cont (create-lset *unspecified*) store)))))
		      (define-cont-address (generate-cont-address)))
		  (set! store (store-update define-cont-address define-cont store))
          (eval-node (define-value node) benv define-cont-address)))
   				                            
   	(define (eval-ref node benv cont)
       (let ((var (lookup-ref-var node ast)))
       	(if var
       		(let ((address (store-benv-lookup benv (var-name var) store)))
       			(for-each (lambda (application)
       							(set! reads (lsetmap-put application address reads)))
       					  (store-stack-applications cont store))
       			(store-cont-call cont (store-lookup-aval address store) store))
       	    (store-cont-call cont (create-lset (eval (ref-name node))) store))))
   	
   	
	(define (eval-set node benv cont)
		(let ((set-cont
                (create-cont cont
                             benv
                             (lambda (values)
                           		(let ((var (lookup-set-var node ast)))
                           		   (if var
                           		       (let ((address (store-benv-lookup benv (var-name var) store)))
                           		         (set! store (store-update-aval address values store))
                           		         (for-each (lambda (application)
                           							 (set! writes (lsetmap-put application address writes)))
                           						   (store-stack-applications cont store))))
                                   (store-cont-call cont (create-lset *unspecified*) store)))))
              (set-cont-address (generate-cont-address)))
        	(set! store (store-update set-cont-address set-cont store))
       		(eval-node (set-value node) benv set-cont-address)))
                                                  
    (define (eval-lambda node benv cont)
       (let ((closure (create-closure node benv)))
       	 (store-cont-call cont (create-lset closure) store)))


	(define (eval-application node benv cont)
	   (let ((operator-cont
               (create-cont cont
                            benv
                            (lambda (operator-values)
                       	      (let ((operands (application-operands node)))
                      	       (set! store (store-cont-add-application cont node store))
                      		   (if (null? operands)
                      		       (apply-proc node operator-values '() benv cont)
                      		       (let loop ((operands operands)
                      		                  (operands-values '()))
                      		         (if (null? operands)
                      		             (apply-proc node operator-values (reverse operands-values) benv cont)
                      		             (let ((operand-cont
                  		                        (create-cont cont
                  		                                     benv
      		                                                 (lambda (operand-values)
      		                                                 	(if (or (> (length operand-values) 4)
      		                                                 		    (member *any* operand-values))
      		                                                 		(store-cont-call cont (create-lset *any*) store)
      		                                     	           	    (loop (cdr operands) (cons operand-values operands-values))))))
      		                                   (operand-cont-address (generate-cont-address)))
                      		               (set! store (store-update operand-cont-address operand-cont store))
                      		               (eval-node (car operands) benv operand-cont-address)))))))))
             (operator-cont-address (generate-cont-address)))
   	     (set! time (time-tick (.getTag node) k time))
         (set! store (store-update operator-cont-address operator-cont store))
         (eval-node (application-operator node) benv operator-cont-address)))
                          		                            
	(define (eval-begin node benv cont)
       (let ((exps (begin-expressions node)))
       	(if (null? exps)
       		(store-cont-call cont (create-lset *unspecified*) store)
       		(let loop ((exps exps))
       		  (if (null? (cdr exps))
       		      (eval-node (car exps) benv cont)
       		      (let ((begin-cont
   		                 (create-cont cont
                                      benv
                                      (lambda (values)
                                      	(loop (cdr exps)))))
                        (begin-cont-address (generate-cont-address)))
                    (set! store (store-update begin-cont-address begin-cont store))
       		      	(eval-node (car exps) benv begin-cont-address)))))))
       		                    
	(define (eval-if node benv cont)
		(let ((if-cont
			   (create-cont cont
			                benv
			                (lambda (values)
			                	(if (and (not (car values)) (null? (cdr values)))
			                		(eval-node (if-alternate node) benv cont)
			                		(if (member #f values)
			                			(let ((time2 (time-tick (.getTag (if-consequent node)) k time))
			                			      (time3 (time-tick (.getTag (if-alternate node)) k time)))
			                				(list (lambda ()
			                						(set! time time2)
			                						(eval-node (if-consequent node) benv cont))
			                					  (lambda ()
			                					  	(set! time time3)
			                					    (eval-node (if-alternate node) benv cont))))
			                	        (eval-node (if-consequent node)
			                	                   benv
			                	                   cont))))))
			  (if-cont-address (generate-cont-address)))
		  (set! store (store-update if-cont-address if-cont-address store))
		  (eval-node (if-condition node) benv if-cont-address)))
				                					

	(define (eval-node node benv-address cont)
		;(d 'before store)
		(set! store (store-gc benv-address cont store))
		;(d 'after store)
		(cond ((literal? node) (eval-literal node benv-address cont))
		      ((define? node) (eval-define node benv-address cont))
		      ((ref? node) (eval-ref node benv-address cont))
		      ((set? node) (eval-set node benv-address cont))
		      ((lambda? node) (eval-lambda node benv-address cont))
		      ((application? node) (eval-application node benv-address cont))
		      ((if? node) (eval-if node benv-address cont))
		      ((begin? node) (eval-begin node benv-address cont))
		      (else
		        (error (String/format "cannot handle node %1s" (vector node))))))
		        
	(define (apply-proc application operator-values operands-values benv cont)
		(map (lambda (operator)
				(lambda ()
					(let* ((calling-context (create-calling-context operator operands-values time))
						   (application-calling-contexts (lsetmap-get application calling-contexts)))
						(if (not (lset-member? calling-context application-calling-contexts))
							(let ((updated-application-calling-contexts (lset-add calling-context application-calling-contexts)))
								(set! calling-contexts (lsetmap-put application updated-application-calling-contexts calling-contexts))
								(if (closure? operator)
									(apply-closure operator operands-values benv cont)
									(apply-primitive operator operands-values benv cont)))))))
				   operator-values))
										
	(define (apply-primitive primitive operands-values benv cont)
		(map (lambda (operands)
				(lambda ()
					(store-cont-call cont (apply primitive operands) store)))
			 (perm operands-values)))
			 
	(define (apply-closure closure operands-values benv cont)
		(let ((lam (closure-lambda closure))
			  (extended-benv-address (generate-benv-address)))
			(set! store (store-alloc-benv extended-benv-address benv store))
			(let loop ((params (lambda-params lam))
			           (operands-values operands-values))
				(if (null? params)
					(eval-node (lambda-body lam) extended-benv-address cont)
					(let* ((param (car params))
					       (address (create-var-address param time)))
					    (set! store (store-benv-extend extended-benv-address (var-name param) address store)) 
						(set! store (store-alloc-aval address (car operands-values) store))
						(loop (cdr params)(cdr operands-values))))))) 


		(let loop ((tasks (list (lambda ()
									(let ((benv-address (generate-benv-address))
									      (exit-cont (create-cont #f
										                          #f
										                          (lambda (values)
															          (set! result (lset-union result values))
											    			          '())))
										  (exit-cont-address (generate-cont-address)))
										(set! store (store-alloc-benv benv-address #f store))
    									(set! store (store-update exit-cont-address exit-cont store))
		  								(eval-node node benv-address exit-cont-address))))))	
			(if (null? tasks)
				(begin
					;(d 'before store)
					(set! store (store-gc #f #f store))
					;(d 'after store)
					(vector result store reads writes))
				(loop (append (cdr tasks) ((car tasks)))))))
		
(define (ipda-result ipda)
	(vector-ref ipda 0))
	
(define (ipda-store ipda)
	(vector-ref ipda 1))
	
(define (ipda-reads ipda)
	(vector-ref ipda 2))
		
(define (ipda-writes ipda)
	(vector-ref ipda 3))				

(define (ipda-application-writes application ipda)
	(assoc application (ipda-writes ipda)))
	
(define ast (create-ast '(begin (define z #f) (define writez (lambda () (set! z 123))) (define readz (lambda () z)) (cons (writez) (readz)))))
(define ipda (ipda-eval ast 12 ast))
(d (ipda-result) 'result)
(d (ipda-store) 'store)
(d (ipda-reads) 'reads)
(d (ipda-writes) 'writes)

(d (filter application? (nodes ast)))

