
(define (d exp . messages)
	(display messages) (display '==>) (display exp) (newline) exp)

(define *any* (Object.))

(define (create-lset . els)
	els)
	
(define (lset-add el s)
	(if (member el s)
		s
		(cons el s)))
		
(define (lset-add-all els s)
	(if (null? els)
		s
		(lset-add-all (cdr els) (lset-add (car els) s))))
				
(define (lset-union ls1 ls2)
	(lset-add-all ls1 ls2))
	
(define (lset-member? el s)
	(member el s))

(define (create-lsetmap)
	'())
	
(define (lsetmap-put key value lsetmap)
	(if (null? lsetmap)
		(list (cons key (create-lset value)))
		(let ((entry (car lsetmap)))
				(if (equal? (car entry) key)
					(cons (cons key (lset-add value (cdr entry))) (cdr lsetmap))
					(cons entry (lsetmap-put key value (cdr lsetmap)))))))

(define (lsetmap-get key lsetmap)
	(let ((entry (assoc key lsetmap)))
		(if entry
			(cdr entry)
			'())))
			
(define (perm l)
  (if (null? (cdr l))
      (map list (car l))
      (let ((rest (perm (cdr l))))
        (apply append (map (lambda (x)
                             (map (lambda (y)
                                    (cons x y))
                                  rest))
                           (car l))))))
			
(define (create-time)
	'())
	
(define (time-tick value k time)
	(let ((result (append time (list value))))
		(if (> (length result) k)
			(cdr result)
			result))) 
	   
(define (create-var-address var time)
	(vector 'var var time))
	
(define (var-address? object)
	(and (vector? object) (eq? 'var (vector-ref object 0))))
	
(define (var-address-var avar)
	(vector-ref avar 1))
	
(define (var-address-time avar)
	(vector-ref avar 2))
	
(define (%create-aval values fresh mono)
	(vector values fresh mono))
	
(define (create-aval values)
	(%create-aval values #t values))
	
(define (aval-values aval)
	(vector-ref aval 0))
	
(define (aval-fresh? aval)
	(vector-ref aval 1))
	
(define (aval-mono aval)
	(vector-ref aval 2))
	
(define (aval-update values aval)
	(if (aval-fresh? aval)
		(aval-strong-update values aval)
		(aval-weak-update values aval)))
		
(define (aval-weak-update values aval)
	(%create-aval (lset-union values (aval-values aval)) #f (lset-union values (aval-mono aval))))
	
(define (aval-strong-update values aval)
	(%create-aval values (aval-fresh? aval) (lset-union values (aval-mono aval))))
	   	   
(define (create-store)
	'())
	
(define (store-lookup-entry address store)
	(assoc address store))

(define (store-lookup address store)
	(let ((entry (store-lookup-entry address store)))
		(if entry
			(cdr entry)
			(error (String/format "no value at address %1s" (vector address))))))

(define (store-update address value store)
	(if (null? store)
		(cons (cons address value) '())
		(let ((entry (car store)))
			  (if (equal? (car entry) address)
			  	(cons (cons address value) (cdr store))
				(cons entry (store-update address value (cdr store)))))))

(define (store-keep-all addresses store)
	(if (null? store)
		'()
		(let ((entry (car store)))
			(if (member (car entry) addresses)
				(cons entry (store-keep-all addresses (cdr store)))
				(store-keep-all addresses (cdr store))))))
	
(define (store-lookup-aval address store)
	(let ((entry (store-lookup-entry address store)))
		(if entry
			(aval-values (cdr entry))
			(error (String/format "no aval to lookup at address %1s" (vector address))))))
	
(define (store-alloc-aval address values store)
	(let ((entry (store-lookup-entry address store)))
		(if entry
			(store-update address (aval-weak-update values (cdr entry)) store)
			(store-update address (create-aval values) store))))
			
(define (store-update-aval address values store)
	(let ((entry (store-lookup-entry address store)))
		(if entry
			(store-update address (aval-update values (cdr entry)) store)
			(error (String/format "no aval to update at address %1s" (vector address))))))

(define generate-benv-address
	(let ((c 0))
		(lambda ()
			(set! c (+ c 1))
			(cons 'benv c))))
			
(define (benv-address? object)
	(and (pair? object) (eq? 'benv (car object))))
			
(define (%create-benv frame parent-pointer)
	(cons frame parent-pointer))
	
(define (benv-frame benv)
	(car benv))	
	
(define (benv-parent-address benv)
	(cdr benv))	

(define (benv-extend name address benv)
	(%create-benv (cons (cons name address) (benv-frame benv)) (benv-parent-address benv)))
	
(define (benv-touches benv)
	(map cdr (benv-frame benv)))
	
(define (store-benv-lookup benv-address name store)
	(if benv-address
		(let* ((benv (store-lookup benv-address store))
		       (entry (assoc name (benv-frame benv))))
			(if entry
				(cdr entry)
				(store-benv-lookup (benv-parent-address benv) name store)))
		(error (String/format "no binding for name %1s" (vector name)))))
	
(define (store-benv-extend benv-address name address store)
	(let ((benv (store-lookup benv-address store)))
		(store-update benv-address (benv-extend name address benv) store)))
		
(define (store-alloc-benv address parent-pointer store)
	(store-update address (%create-benv '() parent-pointer) store))
				
(define (store-benv-touches benv-address store)
	(if benv-address
		(let ((benv (store-lookup benv-address store)))
			(cons benv-address (append (benv-touches benv) (store-benv-touches (benv-parent-address benv) store))))
		'()))
			
(define (%create-cont previous benv applications proc)
	(vector previous benv applications proc))
	
(define (create-cont previous benv proc)
	(%create-cont previous benv '() proc))
	
(define (cont-previous cont)
	(vector-ref cont 0))
	
(define (cont-benv cont)
	(vector-ref cont 1))
	
(define (cont-applications cont)
	(vector-ref cont 2))

(define (cont-proc cont)
	(vector-ref cont 3))	
	
(define (cont-call cont values benv)
	((cont-proc cont) values benv))
	
(define (cont-add-application application cont)
	(%create-cont (cont-previous cont)
	              (cont-benv cont)
	              (cons application (cont-applications cont))
	              (cont-proc cont)))
	              
(define (stack-applications cont)
	(let recur ((current cont)
	           (result '()))
		(if current
			(recur (cont-previous current) (append (cont-applications current) result))
			result))) 
			
(define (create-closure lam benv)
	(vector 'closure lam benv))
	
(define (closure? object)
	(and (vector? object) (eq? (vector-ref object 0) 'closure)))

(define (closure-lambda closure)
	(vector-ref closure 1))
	
(define (closure-benv closure)
	(vector-ref closure 2))
		
(define (create-calling-context operator operands time)
	(vector operator operands time))
			
(define (benv-walker benv-address reachable store)
	(if (or (not benv-address) (lset-member? benv-address reachable))
		reachable
		(let ((benv (store-lookup benv-address store)))
			(benv-walker (benv-parent-address benv) (frame-walker (benv-touches benv) (cons benv-address reachable) store) store))))

(define (frame-walker addresses reachable store)
	(if (null? addresses)
		reachable
		(let ((address (car addresses)))
			(if (lset-member? address reachable)
				(frame-walker (cdr addresses) reachable store)
				(let loop ((values (store-lookup-aval address store))
				           (reachable (cons address reachable)))
					(if (null? values)
						(frame-walker (cdr addresses) reachable store)
						(let ((value (car values)))
							(cond ((closure? value)
							       (loop (cdr values) (benv-walker (closure-benv value) reachable store)))
							      (else (loop (cdr values) reachable))))))))))
							      
(define (cont-walker cont reachable store)
	(if (or (not cont) (lset-member? cont reachable))
		reachable
		(cont-walker (cont-previous cont) (benv-walker (cont-benv cont) reachable store) store)))
		
							     
(define (store-gc benv-address cont store)
	(let ((reachable (cont-walker cont (benv-walker benv-address '() store) store)))
		(store-keep-all reachable store))) 
		
(define (ipda-eval node k ast)
	
	(define result (create-lsetmap))
	(define store (create-store))
	(define reads (create-lsetmap))
	(define writes (create-lsetmap))
	(define calling-contexts (create-lsetmap))
	(define time (create-time))
	
	(define (eval-literal node benv cont)
	   (cont-call cont (create-lset (literal-value node)) benv))
		
	(define (eval-define node benv cont)
       (eval-node (define-value node)
                  benv
                  (create-cont cont
                               benv
                               (lambda (values benv)
                               	(let* ((var (define-var node))
                               	       (address (create-var-address var time)))
                               	 (set! store (store-benv-extend benv (var-name var) address store))  
                                 (set! store (store-alloc-aval address values store)) 
		       				     (cont-call cont
   						   		            (create-lset *unspecified*)
   				                            benv))))))
   				                            
   	(define (eval-ref node benv cont)
       (let ((var (lookup-ref-var node ast)))
       	(if var
       		(let ((address (store-benv-lookup benv (var-name var) store)))
       			(for-each (lambda (application)
       							(set! reads (lsetmap-put application address reads)))
       					  (stack-applications cont))
       			(cont-call cont
       	                   (store-lookup-aval address store)
       	                   benv))
       	    (cont-call cont
       	               (create-lset (eval (ref-name node)))
       	               benv))))
       	    ;(error (String/format "variable %1s not found" (vector node))))))
   	

	(define (eval-set node benv cont)
       (eval-node (set-value node)
                  benv
                  (create-cont cont
                               benv
                               (lambda (values benv)
                               		(let ((var (lookup-set-var node ast)))
                               		   (if var
                               		       (let ((address (store-benv-lookup benv (var-name var) store)))
                               		         (set! store (store-update-aval address values store))
                               		         (for-each (lambda (application)
                               							 (set! writes (lsetmap-put application address writes)))
                               						   (stack-applications cont))))
                                       (cont-call cont
                                                  (create-lset *unspecified*)
                                                  benv))))))
                                                  
    (define (eval-lambda node benv cont)
       (let ((closure (create-closure node benv)))
       	 (cont-call cont
       	            (create-lset closure)
       	            benv)))


	(define (eval-application node benv cont)
	   (set! time (time-tick (.getTag node) k time))
       (eval-node (application-operator node)
                  benv
                  (create-cont cont
                               benv
                               (lambda (operator-values benv)
                          	     (let ((operands (application-operands node))
                          	     	   (marked-cont (cont-add-application node cont)))
                          		   (if (null? operands)
                          		       (apply-proc marked-cont node operator-values '() benv marked-cont)
                          		       (let recur ((operands (reverse operands))
                          		                   (operands-values '())
                          		                   (benv benv))
                          		         (if (null? operands)
                          		             (apply-proc node operator-values operands-values benv marked-cont)
                          		             (eval-node (car operands)
                          		                        benv
                          		                        (create-cont cont
                          		                                     benv
              		                                                 (lambda (operand-values benv)
              		                                                 	(if (or (> (length operand-values) 4)
              		                                                 		    (member *any* operand-values))
              		                                                 		(cont-call marked-cont (create-lset *any*) benv)
              		                                     	           	    (recur (cdr operands) (cons operand-values operands-values) benv)))))))))))))
                          		                            
	(define (eval-begin node benv cont)
       (let ((exps (begin-expressions node)))
       	(if (null? exps)
       		(cont-call cont (create-lset *unspecified*) benv)
       		(let recur ((exps exps)
       		            (benv benv))
       		  (if (null? (cdr exps))
       		      (eval-node (car exps)
       		      			 benv
       		      			 cont)
       		      (eval-node (car exps)
       		                 benv
       		                 (create-cont cont
                                          benv
                                          (lambda (values benv)
                                          	(recur (cdr exps) benv)))))))))
       		                    
	(define (eval-if node benv cont)
		(eval-node (if-condition node)
				   benv
				   (create-cont cont
				                benv
				                (lambda (values benv)
				                	(if (and (not (car values)) (null? (cdr values)))
				                		(eval-node (if-alternate node) benv cont)
				                		(if (member #f values)
				                			(let ((time2 (time-tick (.getTag (if-consequent node)) k time))
				                			      (time3 (time-tick (.getTag (if-alternate node)) k time)))
				                				(list (lambda ()
				                						(set! time time2)
				                						(eval-node (if-consequent node)
				                								   benv
				                								   cont))
				                					  (lambda ()
				                					  	(set! time time3)
				                					    (eval-node (if-alternate node)
				                					               benv
				                					               cont))))
				                	        (eval-node (if-consequent node)
				                	                   benv
				                	                   cont)))))))
				                					

	(define (eval-node node benv-address cont)
		(d 'before store)
		(set! store (store-gc benv-address cont store))
		(d 'after store)
		(cond ((literal? node) (eval-literal node benv-address cont))
		      ((define? node) (eval-define node benv-address cont))
		      ((ref? node) (eval-ref node benv-address cont))
		      ((set? node) (eval-set node benv-address cont))
		      ((lambda? node) (eval-lambda node benv-address cont))
		      ((application? node) (eval-application node benv-address cont))
		      ((if? node) (eval-if node benv-address cont))
		      ((begin? node) (eval-begin node benv-address cont))
		      (else
		        (error (String/format "cannot handle node %1s" (vector node))))))
		        
	(define (apply-proc application operator-values operands-values benv cont)
		(map (lambda (operator)
				(lambda ()
					(let* ((calling-context (create-calling-context operator operands-values time))
						   (application-calling-contexts (lsetmap-get application calling-contexts)))
						(if (not (lset-member? calling-context application-calling-contexts))
							(let ((updated-application-calling-contexts (lset-add calling-context application-calling-contexts)))
								(set! calling-contexts (lsetmap-put application updated-application-calling-contexts calling-contexts))
								(if (closure? operator)
									(apply-closure operator operands-values benv cont)
									(apply-primitive operator operands-values benv cont)))))))
				   operator-values))
										
	(define (apply-primitive primitive operands-values benv cont)
		(map (lambda (operands)
				(lambda ()
					(cont-call cont (apply primitive operands) benv)))
			 (perm operands-values)))
			 
	(define (apply-closure closure operands-values benv cont)
		(let ((lam (closure-lambda closure))
			  (extended-benv-address (generate-benv-address)))
			(set! store (store-alloc-benv extended-benv-address benv store))
			(let loop ((params (lambda-params lam))
			           (operands-values operands-values))
				(if (null? params)
					(eval-node (lambda-body lam)
							   extended-benv-address
							   (create-cont cont
							   				extended-benv-address
							   				(lambda (values extended-benv-address)
							   					(cont-call cont values benv))))
					(let* ((param (car params))
					       (address (create-var-address param time)))
					    (set! store (store-benv-extend extended-benv-address (var-name param) address store)) 
						(set! store (store-alloc-aval address (car operands-values) store))
						(loop (cdr params)(cdr operands-values))))))) 

	(let recur ((tasks (list (lambda ()
	                            (let ((benv-address (generate-benv-address)))
	                            	(set! store (store-alloc-benv benv-address #f store))
									(eval-node node 
				        		   			   benv-address	
						  		               (create-cont #f 
						  		                            benv-address
						  		                            (lambda (values benv-address)
						  		   					          (set! result (lset-union result values))
						  		   					          '()))))))))
		(if (null? tasks)
			(vector result store reads writes)
			(recur (append (cdr tasks) ((car tasks)))))))
		
(define (ipda-result ipda)
	(vector-ref ipda 0))
	
(define (ipda-store ipda)
	(vector-ref ipda 1))
	
(define (ipda-reads ipda)
	(vector-ref ipda 2))
		
(define (ipda-writes ipda)
	(vector-ref ipda 3))				
	
(define ast (create-ast '(begin (if #f 'hey 'ho))))
(display (ipda-eval ast 12 ast))
(newline)